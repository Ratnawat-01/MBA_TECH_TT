<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Table Tennis Tournament</title>
<style>
  /* ✅ Neon glowing heading */
/* ✅ Green neon glowing heading */
h1 {
    --glow-color: rgb(0, 255, 144);
    --glow-spread-color: rgba(0, 255, 144, 0.55);
    --enhanced-glow-color: rgb(120, 255, 190);

    font-size: 2.4em;
    text-align: center;
    color: var(--glow-color);
    text-shadow:
        0 0 0.4em var(--glow-color),
        0 0 1.2em var(--glow-spread-color),
        0 0 2em var(--glow-spread-color);
    transition: all 0.3s ease-in-out;
}

h1:hover {
    text-shadow:
        0 0 0.7em var(--glow-color),
        0 0 2.5em var(--glow-spread-color),
        0 0 4em var(--enhanced-glow-color);
}

/* ✅ Green neon glowing button */
.btn {
    --glow-color: rgb(0, 255, 144);
    --glow-spread-color: rgba(0, 255, 144, 0.75);
    --enhanced-glow-color: rgb(120, 255, 190);
    --btn-color: rgb(23, 211, 139);

    border: 0.25em solid var(--glow-color);
    padding: 0.7em 2em;
    font-weight: bold;
    border-radius: 0.8em;
    cursor: pointer;
    background-color: var(--btn-color);
    color: black;   /* ✅ Always visible */
    font-size: 15px;
    outline: none;
    position: relative;

    box-shadow:
        0 0 0.6em var(--glow-color),
        0 0 1.5em var(--glow-spread-color),
        inset 0 0 0.4em var(--glow-color);

    text-shadow: 0 0 0.4em var(--glow-color);
    transition: all 0.3s ease-in-out;
}

.btn:hover {
    background-color: var(--glow-color);
    color: var(--btn-color);
    transform: scale(1.1);

    box-shadow:
        0 0 1em var(--glow-color),
        0 0 3em var(--glow-spread-color),
        inset 0 0 0.7em var(--enhanced-glow-color);
}

.btn:active {
    transform: scale(0.95);
    box-shadow:
        0 0 0.4em var(--enhanced-glow-color),
        0 0 1.8em var(--glow-spread-color),
        inset 0 0 0.6em var(--enhanced-glow-color);
}


  :root{--bg:#070707;--accent:#00ff90;--card:#111}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(#0b0b0b,#070707);color:#fff}
  .wrap{padding:14px;max-width:900px;margin:0 auto}

/* ❌ No glow — clean table */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 12px 0;
    border: 1px solid rgba(255, 255, 255, 0.08); /* subtle border */
    border-radius: 10px;
    overflow: hidden;
    box-shadow: none !important; /* ensure no glow */
}

th, td {
    padding: 8px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

/* Header stays readable */
th {
    background-color: rgba(0, 0, 0, 0.3);
    color: #ffffff;
    text-shadow: none !important;
}

/* Remove hover glow too */
tbody tr:hover {
    background-color: rgba(255,255,255,0.05);
    box-shadow: none !important;
}


.section {
    box-shadow: 0 0 0.7em rgba(0,255,144,0.25);
    border: 1px solid rgba(0,255,144,0.25);
}


  th{background:rgba(0,0,0,0.3);color:#e6ffe9}

  
/* ✅ Default neon border */
input[type="number"] {
    width: 60px;
    padding: 6px;
    border-radius: 8px;
    border: 2px solid rgba(0,255,144,0.4);
    background: rgba(0, 0, 0, 0.5);
    color: #00ff90;
    text-align: center;
    font-weight: bold;

    /* smooth transition */
    transition: all 0.25s ease-in-out;

    box-shadow:
        0 0 0.4em rgba(0,255,144,0.3),
        inset 0 0 0.4em rgba(0,255,144,0.25);
}

/* ✅ Glowing effect when textbox is focused (user typing) */
input[type="number"]:focus {
    outline: none;
    border-color: #00ff90;
    background: rgba(0, 255, 144, 0.15);
    color: #fff;

    box-shadow:
        0 0 1em rgba(0,255,144,0.7),
        0 0 2em rgba(0,255,144,0.5),
        inset 0 0 0.8em rgba(0,255,144,0.4);
}

/* ✅ Glow slightly when value changes */
input[type="number"]:not(:placeholder-shown) {
    box-shadow:
        0 0 0.8em rgba(0,255,144,0.6),
        inset 0 0 0.6em rgba(0,255,144,0.3);
}

  .section{background:var(--card);padding:12px;border-radius:10px;margin-top:12px;box-shadow:0 6px 20px rgba(0,255,144,0.04)}
  .small{color:#cfcfcf;font-size:0.9rem}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:8px}
  @media(max-width:480px){ input[type="number"]{width:48px} th,td{font-size:0.85rem} .row{flex-direction:column} }
  #ball{position:fixed;width:56px;height:56px;border-radius:50%;background:radial-gradient(circle at 30% 35%, #d6ffea,#00ff90);box-shadow:0 8px 30px rgba(0,255,144,0.12);z-index:40}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Table Tennis Champions</h1>

    <div class="section" id="matchesSection">
      <h2 class="small">Round-robin Matches</h2>
      <div style="overflow:auto">
        <table id="matchesTable">
          <thead><tr><th>#</th><th>Player 1</th><th>Score 1</th><th>Player 2</th><th>Score 2</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div style="text-align:center"><button id="updatePoints" class="btn">Update Points</button></div>
      <div class="small" style="text-align:center;margin-top:6px">Fill match scores then tap Update Points</div>
    </div>

    <div class="section" id="pointsSection">
      <h2 class="small">Points Table</h2>
      <div style="overflow:auto">
        <table id="pointsTable">
          <thead><tr><th>Pos</th><th>Player</th><th>Played</th><th>W</th><th>L</th><th>Pts</th><th>NPR</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="section" id="playoffBox" style="display:none">
      <h2 class="small">Playoffs</h2>
      <div id="playoffsArea"></div>
    </div>

    <div class="section" id="finalBox" style="display:none">
      <h2 class="small">Final</h2>
      <div id="finalArea"></div>
    </div>
  </div>



<script>
/*
  Expected image files in /images/
  e.g. images/kartik.jpg (lowercase filenames recommended).
  Players list can be pulled from URL param 'players' (encoded JSON) else default all.
*/
const url = new URL(window.location.href);
let selectedPlayers;
try {
  selectedPlayers = JSON.parse(decodeURIComponent(url.searchParams.get('players') || 'null')) || 
    ["Kartik","Priyansh","Mradul","Bhavya","Arnav","Kautik","Mann"];
} catch(e){
  selectedPlayers = ["Kartik","Priyansh","Mradul","Bhavya","Arnav","Kautik","Mann"];
}

// Normalize names (keep as-is; filenames must match how you saved them)
const players = selectedPlayers.slice();

// Utilities and state
let matches = []; // {p1,p2,s1,s2}
let stats = {};   // per player

// create round-robin fixtures (all pairs) and shuffle
function genFixtures(list) {
  // Step 1: Generate all pair combinations
  const arr = [];
  for (let i = 0; i < list.length; i++) {
    for (let j = i + 1; j < list.length; j++) {
      arr.push({ p1: list[i], p2: list[j], s1: '', s2: '' });
    }
  }

  // Step 2: Shuffle the array randomly
  for (let i = arr.length - 1; i > 0; i--) {
    const r = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[r]] = [arr[r], arr[i]];
  }

  // Step 3: Fix consecutive duplicate players
  for (let i = 1; i < arr.length; i++) {
    const prev = arr[i - 1];
    const curr = arr[i];
    if (prev.p1 === curr.p1 || prev.p2 === curr.p2 || prev.p1 === curr.p2 || prev.p2 === curr.p1) {
      // find a non-conflicting match to swap with
      for (let j = i + 1; j < arr.length; j++) {
        const next = arr[j];
        if (
          prev.p1 !== next.p1 && prev.p2 !== next.p2 &&
          prev.p1 !== next.p2 && prev.p2 !== next.p1
        ) {
          [arr[i], arr[j]] = [arr[j], arr[i]];
          break;
        }
      }
    }
  }

  return arr;
}


// render match input table
const matchesTbody = document.querySelector('#matchesTable tbody');
function renderMatches(){
  matchesTbody.innerHTML='';
  matches.forEach((m,idx)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td>
      <td>${m.p1}</td>
      <td><input type="number" min="0" id="m_s1_${idx}" value="${m.s1}"></td>
      <td>${m.p2}</td>
      <td><input type="number" min="0" id="m_s2_${idx}" value="${m.s2}"></td>`;
    matchesTbody.appendChild(tr);
  });
}

// points calculation
function resetStats(){
  stats = {};
  players.forEach(p => stats[p] = {played:0, won:0, lost:0, points:0, scored:0, conceded:0, npr:0});
}

function updatePoints(){
  resetStats();
  matches.forEach((m,idx)=>{
    const v1 = document.getElementById(`m_s1_${idx}`).value;
    const v2 = document.getElementById(`m_s2_${idx}`).value;
    if(v1 === '' && v2 === '') return; // unplayed
    const s1 = parseInt(v1 || 0), s2 = parseInt(v2 || 0);
    m.s1 = s1; m.s2 = s2;
    stats[m.p1].played++; stats[m.p2].played++;
    stats[m.p1].scored += s1; stats[m.p1].conceded += s2;
    stats[m.p2].scored += s2; stats[m.p2].conceded += s1;
    if(s1 > s2){ stats[m.p1].won++; stats[m.p2].lost++; stats[m.p1].points += 2; }
    else if(s2 > s1){ stats[m.p2].won++; stats[m.p1].lost++; stats[m.p2].points += 2; }
    else { stats[m.p1].points += 1; stats[m.p2].points += 1; }
  });
  players.forEach(p => stats[p].npr = stats[p].scored - stats[p].conceded);
  renderPoints();
  renderPlayoffs(); // update playoff UI based on latest ordering
}

// render points table sorted by points then npr
const pointsTbody = document.querySelector('#pointsTable tbody');
function renderPoints(){
  const order = players.slice().sort((a,b)=>{
    if(stats[b].points !== stats[a].points) return stats[b].points - stats[a].points;
    return stats[b].npr - stats[a].npr;
  });
  pointsTbody.innerHTML = '';
  order.forEach((p,i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${i+1}</td><td>${p}</td><td>${stats[p].played}</td><td>${stats[p].won}</td><td>${stats[p].lost}</td><td>${stats[p].points}</td><td>${stats[p].npr}</td>`;
    pointsTbody.appendChild(tr);
  });
}

// Playoffs UI and logic
const playoffBox = document.getElementById('playoffBox');
const playoffsArea = document.getElementById('playoffsArea');
const finalBox = document.getElementById('finalBox');
const finalArea = document.getElementById('finalArea');

let lastSorted = []; // cached sorted by points

function renderPlayoffs(){
  // only show after points exist
  lastSorted = players.slice().sort((a,b)=>{
    if(stats[b].points !== stats[a].points) return stats[b].points - stats[a].points;
    return stats[b].npr - stats[a].npr;
  });

  // hide or show
  if(players.length > 5){
    playoffBox.style.display='block';
    finalBox.style.display='block';
    const p1 = lastSorted[0], p2 = lastSorted[1], p3 = lastSorted[2], p4 = lastSorted[3];

    playoffsArea.innerHTML = `
      <div style="margin-bottom:10px"><strong>Qualifier 1:</strong> ${p1} vs ${p2}
        <div class="row"><input id="q1_s1" type="number" placeholder="s1"> vs <input id="q1_s2" type="number" placeholder="s2"></div>
      </div>
      <div style="margin-bottom:10px"><strong>Eliminator:</strong> ${p3} vs ${p4}
        <div class="row"><input id="e_s1" type="number" placeholder="s1"> vs <input id="e_s2" type="number" placeholder="s2"></div>
      </div>
      <div style="margin-top:6px"><button id="computeQ2" class="btn">Compute Q1 & Eliminator → Setup Q2</button></div>
    `;
    document.getElementById('computeQ2').onclick = computeQ2;
    finalArea.innerHTML = ''; // reset final area until Q2 is computed
  } else {
    // direct final top 2
    playoffBox.style.display='none';
    finalBox.style.display='block';
    const finalists = lastSorted.slice(0,2);
    finalArea.innerHTML = `
      <div><strong>Final:</strong> ${finalists[0]} vs ${finalists[1]}</div>
      <div class="row"><input id="f_s1" type="number" placeholder="s1"> vs <input id="f_s2" type="number" placeholder="s2"></div>
      <div style="margin-top:10px"><button id="submitFinal" class="btn">Submit Final</button></div>
    `;
    document.getElementById('submitFinal').onclick = ()=> finishTournament(finalists[0],finalists[1], null);
  }
}

// compute Q2 participants based on q1 and eliminator inputs
function computeQ2(){
  const p1 = lastSorted[0], p2 = lastSorted[1], p3 = lastSorted[2], p4 = lastSorted[3];
  const q1s1 = parseInt(document.getElementById('q1_s1').value || 0);
  const q1s2 = parseInt(document.getElementById('q1_s2').value || 0);
  const es1 = parseInt(document.getElementById('e_s1').value || 0);
  const es2 = parseInt(document.getElementById('e_s2').value || 0);

  // Determine Q1 winner & loser
  let q1Winner = (q1s1 > q1s2) ? p1 : ((q1s2 > q1s1) ? p2 : p1);
  let q1Loser  = (q1Winner === p1) ? p2 : p1;

  // Eliminator winner
  let eWinner = (es1 > es2) ? p3 : ((es2 > es1) ? p4 : p3);
  let eLoser  = (eWinner === p3) ? p4 : p3;

  // Now Q2 = q1Loser vs eWinner
  playoffsArea.innerHTML += `
    <div style="margin-top:10px"><strong>Qualifier 2:</strong> ${q1Loser} vs ${eWinner}
      <div class="row"><input id="q2_s1" type="number" placeholder="s1"> vs <input id="q2_s2" type="number" placeholder="s2"></div>
    </div>
    <div style="margin-top:10px"><button id="computeFinal" class="btn">Compute Q2 → Setup Final</button></div>
  `;

  document.getElementById('computeFinal').onclick = ()=> {
    const q2s1 = parseInt(document.getElementById('q2_s1').value || 0);
    const q2s2 = parseInt(document.getElementById('q2_s2').value || 0);
    let q2Winner = (q2s1 > q2s2) ? q1Loser : ((q2s2 > q2s1) ? eWinner : q1Loser);
    let q2Loser  = (q2Winner === q1Loser) ? eWinner : q1Loser;

    // Final: q1Winner vs q2Winner
    finalArea.innerHTML = `
      <div><strong>Final:</strong> ${q1Winner} vs ${q2Winner}</div>
      <div class="row"><input id="f_s1" type="number" placeholder="s1"> vs <input id="f_s2" type="number" placeholder="s2"></div>
      <div style="margin-top:10px"><button id="submitFinal" class="btn">Submit Final</button></div>
    `;
    document.getElementById('submitFinal').onclick = ()=> finishTournament(q1Winner, q2Winner, {q1Winner,q1Loser,eWinner,eLoser,q2Winner,q2Loser});
  };
}

// finish final: determine placements, save to localStorage and redirect to leaderboard
function finishTournament(finalP1, finalP2, playoffMeta){
  const s1 = parseInt(document.getElementById('f_s1').value || 0);
  const s2 = parseInt(document.getElementById('f_s2').value || 0);
  let first = s1 > s2 ? finalP1 : finalP2;
  let second = s1 > s2 ? finalP2 : finalP1;

  // compute third, fourth based on playoff meta if present
  let third = null, fourth = null;
  let rest = [];

  if(playoffMeta){
    // third = loser of Q2
    third = playoffMeta.q2Loser || null;
    // fourth = eliminator loser (eLoser)
    fourth = playoffMeta.eLoser || null;
    // remaining (5-7) -> players not in top4
    const top4 = new Set([playoffMeta.q1Winner, playoffMeta.q1Loser, playoffMeta.eWinner, playoffMeta.eLoser, playoffMeta.q2Winner, playoffMeta.q2Loser]);
    rest = players.filter(p => !top4.has(p));
    // If rest fewer than needed, fill using points ordering excluding top 4:
    if(rest.length < 0) rest = [];
  } else {
    // no playoffs (<=5 players), third = next by points
    const ordered = players.slice().sort((a,b)=>{
      if(stats[b].points !== stats[a].points) return stats[b].points - stats[a].points;
      return stats[b].npr - stats[a].npr;
    });
    third = ordered[2] || null;
    fourth = ordered[3] || null;
    rest = ordered.slice(4);
  }

  // For safety: if third/fourth are null, try to pick from points order excluding first & second
  const orderedPts = players.slice().sort((a,b)=>{
    if(stats[b].points !== stats[a].points) return stats[b].points - stats[a].points;
    return stats[b].npr - stats[a].npr;
  });
  // build final placements 1..7
  const placed = [first, second];
  // pick third
  if(!third) {
    for(const p of orderedPts) if(!placed.includes(p)){ third = p; break; }
  }
  if(third) placed.push(third);
  // pick fourth
  if(!fourth) {
    for(const p of orderedPts) if(!placed.includes(p)){ fourth = p; break; }
  }
  if(fourth) placed.push(fourth);
  // remaining fill by points order
  for(const p of orderedPts) if(!placed.includes(p)) placed.push(p);
  // ensure length 7 (pad with empty if necessary)
  while(placed.length < players.length) placed.push('');

  // final placements array of length players.length in order 1..N
  const placements = placed.slice(0, players.length);

  // Save to localStorage
  localStorage.setItem('leaderboardPositions', JSON.stringify(placements));
  // redirect to leaderboard
  window.location.href = 'leaderboard.html';
}

// initialize
function init(){
  matches = genFixtures(players);
  renderMatches();
  resetStats();
  renderPoints();
  renderPlayoffs();

}

document.getElementById('updatePoints').addEventListener('click', updatePoints);
window.addEventListener('load', init);
window.addEventListener('resize', ()=>{ /* no-op for now */ });
</script>
</body>
</html>
